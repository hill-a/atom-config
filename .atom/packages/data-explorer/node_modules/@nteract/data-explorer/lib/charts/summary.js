"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const d3_scale_1 = require("d3-scale");
const React = __importStar(require("react"));
const HTMLLegend_1 = __importDefault(require("../HTMLLegend"));
const tooltip_content_1 = __importDefault(require("../tooltip-content"));
const utilities_1 = require("../utilities");
const fontScale = d3_scale_1.scaleLinear()
    .domain([8, 25])
    .range([14, 8])
    .clamp(true);
exports.semioticSummaryChart = (data, schema, options) => {
    const additionalSettings = {};
    const colorHash = {};
    const { chart, summaryType, primaryKey, colors, setColor } = options;
    const { dim1, metric1 } = chart;
    const oAccessor = dim1;
    const rAccessor = metric1;
    const uniqueValues = data.reduce((uniqueArray, datapoint) => (!uniqueArray.find((dimValue) => dimValue === datapoint[dim1].toString()) && [...uniqueArray, datapoint[dim1].toString()]) ||
        uniqueArray, []);
    if (dim1 && dim1 !== "none") {
        uniqueValues.forEach((dimValue, index) => {
            colorHash[dimValue] = colors[index % colors.length];
        });
        additionalSettings.afterElements = (React.createElement(HTMLLegend_1.default, { valueHash: {}, values: uniqueValues, colorHash: colorHash, setColor: setColor, colors: colors }));
    }
    const summarySettings = Object.assign({ summaryType: { type: summaryType, bins: 16, amplitude: 20 }, type: summaryType === "violin" && "swarm", projection: "horizontal", data,
        oAccessor,
        rAccessor, summaryStyle: (summaryDatapoint) => ({
            fill: colorHash[summaryDatapoint[dim1]] || colors[0],
            fillOpacity: 0.8,
            stroke: colorHash[summaryDatapoint[dim1]] || colors[0]
        }), style: (pieceDatapoint) => ({
            fill: colorHash[pieceDatapoint[dim1]] || colors[0],
            stroke: "white"
        }), oPadding: 5, oLabel: uniqueValues.length > 30
            ? false
            : (columnName) => (React.createElement("text", { textAnchor: "end", fontSize: `${(columnName && fontScale(columnName.length)) ||
                    12}px` }, columnName)), margin: { top: 25, right: 10, bottom: 50, left: 100 }, axis: {
            orient: "bottom",
            label: rAccessor,
            tickFormat: utilities_1.numeralFormatting
        }, baseMarkProps: { forceUpdate: true }, pieceHoverAnnotation: summaryType === "violin", tooltipContent: (hoveredDatapoint) => {
            return (React.createElement(tooltip_content_1.default, { x: hoveredDatapoint.x, y: hoveredDatapoint.y },
                React.createElement("h3", null, primaryKey.map(pkey => hoveredDatapoint[pkey]).join(", ")),
                React.createElement("p", null,
                    dim1,
                    ": ",
                    hoveredDatapoint[dim1]),
                React.createElement("p", null,
                    rAccessor,
                    ": ",
                    hoveredDatapoint[rAccessor])));
        } }, additionalSettings);
    return summarySettings;
};
