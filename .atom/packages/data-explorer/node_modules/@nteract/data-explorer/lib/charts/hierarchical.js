"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const d3_collection_1 = require("d3-collection");
const d3_interpolate_1 = require("d3-interpolate");
const React = __importStar(require("react"));
const tooltip_content_1 = __importDefault(require("../tooltip-content"));
const parentPath = (datapoint, pathArray) => {
    if (datapoint.parent) {
        pathArray = parentPath(datapoint.parent, [datapoint.key, ...pathArray]);
    }
    else {
        pathArray = ["root", ...pathArray];
    }
    return pathArray;
};
const hierarchicalTooltip = (datapoint, primaryKey, metric) => {
    const pathString = datapoint.parent
        ? parentPath(datapoint.parent, (datapoint.key && [datapoint.key]) || []).join("->")
        : "";
    const content = [];
    if (!datapoint.parent) {
        content.push(React.createElement("h2", { key: "hierarchy-title" }, "Root"));
    }
    else if (datapoint.key) {
        content.push(React.createElement("h2", { key: "hierarchy-title" }, datapoint.key));
        content.push(React.createElement("p", { key: "path-string" }, pathString));
        content.push(React.createElement("p", { key: "hierarchy-value" },
            "Total Value: ",
            datapoint.value));
        content.push(React.createElement("p", { key: "hierarchy-children" },
            "Children: ",
            datapoint.children.length));
    }
    else {
        content.push(React.createElement("p", { key: "leaf-label" },
            pathString,
            "->",
            primaryKey.map((pkey) => datapoint[pkey]).join(", ")));
        content.push(React.createElement("p", { key: "hierarchy-value" },
            metric,
            ": ",
            datapoint[metric]));
    }
    return content;
};
const hierarchicalColor = (colorHash, datapoint) => {
    if (datapoint.depth === 0) {
        return "white";
    }
    if (datapoint.depth === 1) {
        return colorHash[datapoint.key];
    }
    let colorNode = datapoint;
    for (let x = datapoint.depth; x > 1; x--) {
        colorNode = colorNode.parent;
    }
    const lightenScale = d3_interpolate_1.interpolateLab("white", colorHash[colorNode.key]);
    return lightenScale(Math.max(0, datapoint.depth / 6));
};
exports.semioticHierarchicalChart = (data, schema, options) => {
    const { hierarchyType: baseHierarchyType = "dendrogram", chart, selectedDimensions, primaryKey, colors } = options;
    const { metric1 } = chart;
    // a sunburst is just a radial partition
    const hierarchyType = baseHierarchyType === "sunburst" ? "partition" : baseHierarchyType;
    if (selectedDimensions.length === 0) {
        return {};
    }
    const nestingParams = d3_collection_1.nest();
    selectedDimensions.forEach((dim) => {
        nestingParams.key((param) => param[dim]);
    });
    const colorHash = {};
    const sanitizedData = [];
    data.forEach((datapoint) => {
        if (!colorHash[datapoint[selectedDimensions[0]]]) {
            colorHash[datapoint[selectedDimensions[0]]] =
                colors[Object.keys(colorHash).length];
        }
        sanitizedData.push(Object.assign(Object.assign({}, datapoint), { sanitizedR: datapoint.r, r: undefined }));
    });
    const entries = nestingParams.entries(sanitizedData);
    const rootNode = { values: entries };
    return {
        edges: rootNode,
        edgeStyle: () => ({ fill: "lightgray", stroke: "gray" }),
        nodeStyle: (node) => {
            return {
                fill: hierarchicalColor(colorHash, node),
                stroke: node.depth === 1 ? "white" : "black",
                strokeOpacity: node.depth * 0.1 + 0.2
            };
        },
        networkType: {
            type: hierarchyType,
            projection: baseHierarchyType === "sunburst" && "radial",
            hierarchySum: (node) => node[metric1],
            hierarchyChildren: (node) => node.values,
            padding: hierarchyType === "treemap" ? 3 : 0
        },
        edgeRenderKey: (edge, index) => {
            return index;
        },
        baseMarkProps: { forceUpdate: true },
        margin: { left: 100, right: 100, top: 10, bottom: 10 },
        hoverAnnotation: [
            { type: "frame-hover" },
            {
                type: "highlight",
                style: {
                    stroke: "red",
                    strokeOpacity: 0.5,
                    strokeWidth: 5,
                    fill: "none"
                }
            }
        ],
        tooltipContent: (hoveredDatapoint) => {
            return (React.createElement(tooltip_content_1.default, { x: hoveredDatapoint.x, y: hoveredDatapoint.y }, hierarchicalTooltip(hoveredDatapoint, primaryKey, metric1)));
        }
    };
};
