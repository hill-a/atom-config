"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const grid_1 = __importDefault(require("./charts/grid"));
const settings_1 = require("./charts/settings");
const Toolbar_1 = require("./components/Toolbar");
exports.Toolbar = Toolbar_1.Toolbar;
const Viz_1 = require("./components/Viz");
exports.Viz = Viz_1.Viz;
const settings_2 = require("./settings");
const VizControls_1 = __importDefault(require("./VizControls"));
const mediaType = "application/vnd.dataresource+json";
const styled_components_1 = __importDefault(require("styled-components"));
const Dx = __importStar(require("./types"));
const generateChartKey = ({ view, lineType, areaType, selectedDimensions, selectedMetrics, pieceType, summaryType, networkType, hierarchyType, trendLine, marginalGraphics, barGrouping, chart }) => `${view}-${lineType}-${areaType}-${selectedDimensions.join(",")}-${selectedMetrics.join(",")}-${pieceType}-${summaryType}-${networkType}-${hierarchyType}-${trendLine}-${marginalGraphics}-${barGrouping}-${JSON.stringify(chart)}`;
/*
  contour is an option for scatterplot
  pie is a transform on bar
*/
const defaultResponsiveSize = [500, 300];
const MetadataWarningWrapper = styled_components_1.default.div `
  & {
    font-family: Source Sans Pro, Helvetica Neue, Helvetica, Arial, sans-serif;
  }
`;
const MetadataWarningContent = styled_components_1.default.div `
  & {
    backgroundcolor: #cce;
    padding: 10px;
    paddingleft: 20px;
  }
`;
const MetadataWarning = ({ metadata }) => {
    const warning = metadata && metadata.sampled ? (React.createElement("span", null,
        React.createElement("b", null, "NOTE:"),
        " This data is sampled")) : null;
    return (React.createElement(MetadataWarningWrapper, null, warning ? (React.createElement(MetadataWarningContent, null, warning)) : null));
};
const FlexWrapper = styled_components_1.default.div `
  display: flex;
  flex-flow: row nowrap;
  width: 100%;
`;
const SemioticWrapper = styled_components_1.default.div `
  width: 100%;
  .html-legend-item {
    color: var(--theme-app-fg);
  }

  .tick > path {
    stroke: lightgray;
  }

  .axis-labels,
  .ordinal-labels {
    fill: var(--theme-app-fg);
    font-size: 14px;
  }

  path.connector,
  path.connector-end {
    stroke: var(--theme-app-fg);
  }

  path.connector-end {
    fill: var(--theme-app-fg);
  }

  text.annotation-note-label,
  text.legend-title,
  .legend-item text {
    fill: var(--theme-app-fg);
    stroke: none;
  }

  .xyframe-area > path {
    stroke: var(--theme-app-fg);
  }

  .axis-baseline {
    stroke-opacity: 0.25;
    stroke: var(--theme-app-fg);
  }
  circle.frame-hover {
    fill: none;
    stroke: gray;
  }
  .rect {
    stroke: green;
    stroke-width: 5px;
    stroke-opacity: 0.5;
  }
  rect.selection {
    opacity: 0.5;
  }
`;
class DataExplorer extends React.PureComponent {
    constructor(props) {
        super(props);
        this.updateChart = (updatedState) => {
            const { view, dimensions, metrics, chart, lineType, areaType, selectedDimensions, selectedMetrics, pieceType, summaryType, networkType, hierarchyType, trendLine, marginalGraphics, barGrouping, colors, primaryKey, data: stateData } = Object.assign(Object.assign({}, this.state), updatedState);
            if (!this.props.data && !this.props.metadata && !this.props.initialView) {
                return;
            }
            const { data, height } = this.props;
            const { Frame, chartGenerator } = settings_1.semioticSettings[view];
            const chartKey = generateChartKey({
                view,
                lineType,
                areaType,
                selectedDimensions,
                selectedMetrics,
                pieceType,
                summaryType,
                networkType,
                hierarchyType,
                chart,
                trendLine,
                marginalGraphics,
                barGrouping
            });
            const frameSettings = chartGenerator(stateData, data.schema, {
                metrics,
                dimensions,
                chart,
                colors,
                height,
                lineType,
                areaType,
                selectedDimensions,
                selectedMetrics,
                pieceType,
                summaryType,
                networkType,
                hierarchyType,
                primaryKey,
                trendLine,
                marginalGraphics,
                barGrouping,
                setColor: this.setColor
            });
            const display = (React.createElement(SemioticWrapper, null,
                React.createElement(Frame, Object.assign({ responsiveWidth: true, size: defaultResponsiveSize }, frameSettings)),
                React.createElement(VizControls_1.default, Object.assign({}, {
                    data: stateData,
                    view,
                    chart,
                    metrics,
                    dimensions,
                    selectedDimensions,
                    selectedMetrics,
                    hierarchyType,
                    summaryType,
                    networkType,
                    trendLine,
                    marginalGraphics,
                    barGrouping,
                    updateChart: this.updateChart,
                    updateDimensions: this.updateDimensions,
                    setLineType: this.setLineType,
                    updateMetrics: this.updateMetrics,
                    lineType,
                    setAreaType: this.setAreaType,
                    areaType
                }))));
            // If you pass an onMetadataChange function, then fire it and pass the updated dx settings so someone upstream can update the metadata or otherwise use it
            this.updateMetadata({
                view,
                lineType,
                areaType,
                selectedDimensions,
                selectedMetrics,
                pieceType,
                summaryType,
                networkType,
                hierarchyType,
                trendLine,
                marginalGraphics,
                barGrouping,
                colors,
                chart
            });
            this.setState((prevState) => {
                return Object.assign(Object.assign({}, updatedState), { displayChart: Object.assign(Object.assign({}, prevState.displayChart), { [chartKey]: display }) });
            });
        };
        this.setView = (view) => {
            this.updateChart({ view });
        };
        this.updateMetadata = (overrideProps) => {
            const { onMetadataChange, metadata } = this.props;
            const { view, lineType, areaType, selectedDimensions, selectedMetrics, pieceType, summaryType, networkType, hierarchyType, trendLine, marginalGraphics, barGrouping, colors, chart } = this.state;
            if (onMetadataChange) {
                onMetadataChange(Object.assign(Object.assign({}, metadata), { dx: Object.assign({ view,
                        lineType,
                        areaType,
                        selectedDimensions,
                        selectedMetrics,
                        pieceType,
                        summaryType,
                        networkType,
                        hierarchyType,
                        trendLine,
                        marginalGraphics,
                        barGrouping,
                        colors,
                        chart }, overrideProps) }), mediaType);
            }
        };
        this.setGrid = () => {
            this.updateMetadata({ view: "grid" });
            this.setState({ view: "grid" });
        };
        this.setColor = (newColorArray) => {
            this.updateChart({ colors: newColorArray });
        };
        this.setLineType = (selectedLineType) => {
            this.updateChart({ lineType: selectedLineType });
        };
        this.setAreaType = (selectedAreaType) => {
            this.updateChart({ areaType: selectedAreaType });
        };
        this.updateDimensions = (selectedDimension) => {
            const oldDims = this.state.selectedDimensions;
            const newDimensions = oldDims.indexOf(selectedDimension) === -1
                ? [...oldDims, selectedDimension]
                : oldDims.filter(dimension => dimension !== selectedDimension);
            this.updateChart({ selectedDimensions: newDimensions });
        };
        this.updateMetrics = (selectedMetric) => {
            const oldMetrics = this.state.selectedMetrics;
            const newMetrics = oldMetrics.indexOf(selectedMetric) === -1
                ? [...oldMetrics, selectedMetric]
                : oldMetrics.filter(metric => metric !== selectedMetric);
            this.updateChart({ selectedMetrics: newMetrics });
        };
        const { metadata, initialView } = props;
        // Handle case of metadata being empty yet dx not set
        const dx = metadata.dx || {};
        const chart = dx.chart || {};
        let { fields = [], primaryKey = [] } = props.data.schema;
        // Provide a default primaryKey if none provided
        if (primaryKey.length === 0) {
            primaryKey = [Dx.defaultPrimaryKey];
            fields = [...fields, { name: Dx.defaultPrimaryKey, type: "integer" }];
        }
        const dimensions = fields
            .filter(field => field.type === "string" ||
            field.type === "boolean" ||
            field.type === "datetime")
            .map(field => (Object.assign(Object.assign({}, field), { cardinality: 0 })));
        // Should datetime data types be transformed into js dates before getting to this resource?
        const data = props.data.data.map((datapoint, datapointIndex) => {
            const mappedDatapoint = Object.assign({}, datapoint);
            fields.forEach(field => {
                if (field.name === Dx.defaultPrimaryKey) {
                    mappedDatapoint[Dx.defaultPrimaryKey] = datapointIndex;
                }
                if (field.type === "datetime") {
                    mappedDatapoint[field.name] = new Date(mappedDatapoint[field.name]);
                }
            });
            return mappedDatapoint;
        });
        let largeDataset = true;
        let selectedDimensions = [];
        if (data.length < 5000) {
            largeDataset = false;
            const cardinalityHash = {};
            dimensions.forEach(dim => {
                cardinalityHash[dim.name] = {};
                data.forEach(datapoint => {
                    const dimValue = datapoint[dim.name];
                    cardinalityHash[dim.name][dimValue] = true;
                });
                dim.cardinality = Object.entries(cardinalityHash[dim.name]).length;
            });
            selectedDimensions = dimensions
                .sort((a, b) => a.cardinality - b.cardinality)
                .filter((data, index) => index === 0)
                .map(dim => dim.name);
        }
        const metrics = fields
            .filter(field => field.type === "integer" ||
            field.type === "number" ||
            field.type === "datetime")
            .filter(field => !primaryKey.find(pkey => pkey === field.name));
        const displayChart = {};
        this.state = Object.assign({ largeDataset, view: initialView, lineType: "line", areaType: "hexbin", trendLine: "none", marginalGraphics: "none", barGrouping: "Clustered", selectedDimensions, selectedMetrics: [], pieceType: "bar", summaryType: "violin", networkType: "force", hierarchyType: "dendrogram", dimensions,
            metrics,
            colors: settings_2.colors, 
            // ui: {},
            chart: Object.assign({ metric1: (metrics[0] && metrics[0].name) || "none", metric2: (metrics[1] && metrics[1].name) || "none", metric3: "none", metric4: "none", dim1: (dimensions[0] && dimensions[0].name) || "none", dim2: (dimensions[1] && dimensions[1].name) || "none", dim3: "none", timeseriesSort: "array-order", networkLabel: "none" }, chart), displayChart,
            primaryKey,
            data }, dx);
    }
    componentDidMount() {
        // This is necessary to render any charts based on passed metadata because the grid doesn't result from the updateChart function but any other view does
        if (this.state.view !== "grid") {
            this.updateChart(this.state);
        }
    }
    render() {
        const { view, dimensions, chart, lineType, areaType, selectedDimensions, selectedMetrics, pieceType, summaryType, networkType, hierarchyType, trendLine, marginalGraphics, barGrouping, largeDataset } = this.state;
        let display = null;
        if (view === "grid") {
            display = React.createElement(grid_1.default, Object.assign({}, this.props));
        }
        else if ([
            "line",
            "scatter",
            "bar",
            "network",
            "summary",
            "hierarchy",
            "hexbin",
            "parallel"
        ].includes(view)) {
            const chartKey = generateChartKey({
                view,
                lineType,
                areaType,
                selectedDimensions,
                selectedMetrics,
                pieceType,
                summaryType,
                networkType,
                hierarchyType,
                chart,
                trendLine,
                marginalGraphics,
                barGrouping
            });
            display = this.state.displayChart[chartKey];
        }
        const children = React.Children.map(this.props.children, child => {
            if (!React.isValidElement(child)) {
                return;
            }
            const { componentType } = child.props;
            if (componentType === "viz") {
                const newProps = { children: display };
                return React.cloneElement(child, newProps);
            }
            else if (componentType === "toolbar") {
                const toolbarProps = {
                    dimensions,
                    currentView: view,
                    setGrid: this.setGrid,
                    setView: this.setView,
                    largeDataset
                };
                return React.cloneElement(child, toolbarProps);
            }
            return child;
        });
        return (React.createElement("div", null,
            React.createElement(MetadataWarning, { metadata: this.props.metadata }),
            React.createElement(FlexWrapper, null, children)));
    }
}
exports.DataExplorer = DataExplorer;
DataExplorer.MIMETYPE = mediaType;
DataExplorer.defaultProps = {
    metadata: {
        dx: {}
    },
    height: 500,
    mediaType,
    initialView: "grid"
};
const DataExplorerDefault = (props) => {
    return (React.createElement(DataExplorer, Object.assign({}, props),
        React.createElement(Viz_1.Viz, null),
        React.createElement(Toolbar_1.Toolbar, null)));
};
DataExplorerDefault.defaultProps = {
    mediaType
};
DataExplorerDefault.displayName = "DataExplorerDefault";
// For the jupyter extension to load MIMETYPE must be present.
DataExplorerDefault.MIMETYPE = mediaType;
exports.default = DataExplorerDefault;
